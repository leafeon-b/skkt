datasource db {
  provider = "postgresql"
}

generator client {
  provider               = "prisma-client"
  output                 = "../generated/prisma"
  runtime                = "nodejs"
  moduleFormat           = "esm"
  generatedFileExtension = "ts"
  importFileExtension    = "ts"
}

enum CircleRole {
  CircleOwner
  CircleManager
  CircleMember
}

enum CircleSessionRole {
  CircleSessionOwner
  CircleSessionManager
  CircleSessionMember
}

enum MatchOutcome {
  P1_WIN
  P2_WIN
  DRAW
  UNKNOWN
}

enum MatchHistoryAction {
  CREATE
  UPDATE
  DELETE
}

model User {
  id        String   @id @default(cuid())
  name      String?
  createdAt DateTime @default(now())

  email         String?   @unique
  emailVerified DateTime?
  image         String?
  passwordHash      String?
  passwordChangedAt DateTime?

  circleMemberships        CircleMembership[]
  circleSessionMemberships CircleSessionMembership[]

  matchesAsPlayer1 Match[] @relation("MatchPlayer1")
  matchesAsPlayer2 Match[] @relation("MatchPlayer2")

  matchHistories MatchHistory[]

  accounts Account[]
  sessions Session[]

  createdInviteLinks CircleInviteLink[]
}

model Circle {
  id        String   @id @default(cuid())
  name      String
  createdAt DateTime @default(now())

  circleSessions    CircleSession[]
  circleMemberships CircleMembership[]
  inviteLinks       CircleInviteLink[]
}

model CircleInviteLink {
  id              String   @id @default(cuid())
  circleId        String
  token           String   @unique
  createdByUserId String
  expiresAt       DateTime
  createdAt       DateTime @default(now())

  circle    Circle @relation(fields: [circleId], references: [id], onDelete: Cascade)
  createdBy User   @relation(fields: [createdByUserId], references: [id], onDelete: Restrict)

  @@index([circleId])
}

model CircleSession {
  id        String   @id @default(cuid())
  circleId  String
  createdAt DateTime @default(now())

  title String

  /// 複数日開催も許容
  startsAt DateTime
  endsAt   DateTime
  location String?
  note     String   @default("")

  circle Circle @relation(fields: [circleId], references: [id], onDelete: Cascade)

  circleSessionMemberships CircleSessionMembership[]
  matches                  Match[]

  @@map("CircleSession")
}

model CircleMembership {
  id        String     @id @default(cuid())
  userId    String
  circleId  String
  role      CircleRole
  createdAt DateTime   @default(now())

  /// 論理削除（脱退・除名時にセットし、再参加時に新レコードを作成）
  deletedAt DateTime?

  user   User   @relation(fields: [userId], references: [id], onDelete: Restrict)
  circle Circle @relation(fields: [circleId], references: [id], onDelete: Cascade)

  /// 研究会参加（継続的所属）。アクティブレコード（deletedAt IS NULL）の一意性は部分ユニークインデックスで担保。
  /// 部分ユニークインデックスは migration 20260219083336 で作成。
  /// ⚠ @@unique を再追加しないこと（deletedAt を含む論理削除レコードが一意性制約に違反するため）。
  @@index([circleId, role])
}

model CircleSessionMembership {
  id              String            @id @default(cuid())
  userId          String
  circleSessionId String
  role            CircleSessionRole
  createdAt       DateTime          @default(now())

  /// 論理削除（退出時にセットし、再参加時に新レコードを作成）
  deletedAt DateTime?

  user    User          @relation(fields: [userId], references: [id], onDelete: Restrict)
  session CircleSession @relation(fields: [circleSessionId], references: [id], onDelete: Cascade)

  /// セッション参加（単発参加）。アクティブレコード（deletedAt IS NULL）の一意性は部分ユニークインデックスで担保。
  /// 部分ユニークインデックスは migration 20260219083336 で作成。
  /// ⚠ @@unique を再追加しないこと（deletedAt を含む論理削除レコードが一意性制約に違反するため）。
  @@index([circleSessionId])
  @@index([circleSessionId, role])
  @@map("CircleSessionMembership")
}

model Match {
  id              String   @id @default(cuid())
  circleSessionId String
  createdAt       DateTime

  player1Id String
  player2Id String
  outcome   MatchOutcome

  /// 論理削除（DELETEはこれをセットし、履歴にDELETEを積む）
  deletedAt DateTime?

  session CircleSession @relation(fields: [circleSessionId], references: [id], onDelete: Cascade)

  player1 User @relation("MatchPlayer1", fields: [player1Id], references: [id], onDelete: Restrict)
  player2 User @relation("MatchPlayer2", fields: [player2Id], references: [id], onDelete: Restrict)

  histories MatchHistory[]

  /// NOTE:
  /// - player1Id != player2Id はDB CHECK制約で担保（migrationにSQL追加）
  /// - 対局者がセッション参加者であることはアプリ層で検証
  @@index([circleSessionId, createdAt])
  @@index([player1Id])
  @@index([player2Id])
}

model MatchHistory {
  id        String             @id @default(cuid())
  matchId   String
  editorId  String
  action    MatchHistoryAction
  createdAt DateTime

  // スナップショット（編集時点）
  player1Id String
  player2Id String
  outcome   MatchOutcome

  match  Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  editor User  @relation(fields: [editorId], references: [id], onDelete: Restrict)

  /// 1つのMatchの履歴を実行順で取得しやすくする
  @@index([matchId, createdAt, id])
  @@index([editorId, createdAt])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
}
